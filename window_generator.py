# Basic idea: yield window for each apk or return info for next apk
import random
from random import shuffle
from config import *
import os
from androguard.misc import AnalyzeAPK
from networkx import ego_graph
from feature_generator import Feature_Generator


class Window_Generator:

    def __init__(self):
        # load apks and split into training and test data
        self.mal_train, self.mal_test = self.load_and_label_data(maleware_path, 1)
        self.good_train, self.good_test = self.load_and_label_data(goodware_path, 0)
        self.APKs = self.good_train + self.mal_train
        # randomise order
        shuffle(self.APKs)
        self.apk_iter = iter(self.APKs)
        self.feature_generator = Feature_Generator()

        self.current_graph = None
        self.current_label = None
        self.current_package = None
        self.entrypoints = None

    @staticmethod
    def load_and_label_data(apkpath, label, percentage_test=0.2):
        """
        generate labeled list of data
        :param apkpath: path to apk dir
        :param label: label for data
        :param percentage_test: proportion of test and training data, value with leading 0
        :return:
        """
        apps = os.listdir(apkpath)
        num_test = len(apps) * percentage_test
        data_test = []
        while len(data_test) < num_test:
            data_test.append(tuple([os.path.join(goodware_path, apps.pop(random.randint(0, len(data_test)-1))), label]))
        data_train = []
        while len(apps) > 0:
            data_train.append(tuple([os.path.join(goodware_path, apps.pop(random.randint(0, len(data_test)-1))), label]))
        return data_train, data_test

    def retrieve_call_graph(self, apk):
        """
        Analyse apk wth androguard and recieve static call graph
        :param apk: path to apk
        :return: static call graph
        """
        a, d, dx = AnalyzeAPK(apk)
        print(a.get_package())
        self.current_package = a.get_package()
        graph = dx.get_call_graph(classname='L'+a.get_package().replace('.', '/')+'/*')
        #graph = dx.get_call_graph()
        #print(graph.order())
        return graph

    def find_entrypoints(self, graph):
        entrypoints = []
        for n in graph.nodes:
            try:
                next(graph.predecessors(n))
            except StopIteration:
                if n.get_class_name().startswith('L'+self.current_package.replace('.', '/')):
                    entrypoints.append(n)
        self.entrypoints = iter(entrypoints)

    def analyse_apk(self):
        apk, self.current_label = next(self.apk_iter)
        self.current_graph = self.retrieve_call_graph(apk)
        self.find_entrypoints(self.current_graph)

    def next_training_data(self, success):
        if success:
            print('*************************************************************')
            print('Analysing next APK')
            # if current apk yields good results, use next apk for training
            self.analyse_apk()
            # load next entrypoint in call graph and generate features
        try:
            entry = next(self.entrypoints)
            subgraph = ego_graph(self.current_graph, entry, radius=3)
            return self.feature_generator.generate_features(subgraph), self.current_label
        except StopIteration:
            return None