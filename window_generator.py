# Basic idea: yield window for each apk or return info for next apk
from random import shuffle
from config import *
import os
from androguard.misc import AnalyzeAPK
from networkx import ego_graph
from feature_generator import Feature_Generator


class Window_Generator:

    def retrieve_call_graph(self, apk):
        a, d, dx = AnalyzeAPK(apk)
        print(a.get_package())
        graph = dx.get_call_graph(classname='L'+a.get_package().replace('.', '/')+'/*')
        #graph = dx.get_call_graph()
        #print(graph.order())
        return graph

    def __init__(self):
        self.APKs = []
        for file in os.listdir(maleware_path):
            self.APKs.append(tuple([os.path.join(maleware_path, file), 1]))
        for file in os.listdir(goodware_path):
            self.APKs.append(tuple([os.path.join(goodware_path, file), 0]))
        shuffle(self.APKs)
        self.apk_iter = iter(self.APKs)
        self.feature_generator = Feature_Generator()

        self.current_graph = None
        self.current_label = None
        self.entrypoints = None

    def find_entrypoints(self, graph):
        entrypoints = []
        for n in graph.nodes:
            try:
                next(graph.predecessors(n))
            except StopIteration:
                entrypoints.append(n)
        self.entrypoints = iter(entrypoints)

    def analyse_apk(self):
        apk, self.current_label = next(self.apk_iter)
        self.current_graph = self.retrieve_call_graph(apk)
        self.find_entrypoints(self.current_graph)

    def next_training_data(self, success):
        if success:
            # if current apk yields good results, use next apk for training
            self.analyse_apk()
        try:
            # load next entrypoint in call graph and generate features
            entry = next(self.entrypoints)
            subgraph = ego_graph(self.current_graph, entry, radius=3)
            return self.feature_generator.generate_features(subgraph), self.current_label
        except Exception:
            return None