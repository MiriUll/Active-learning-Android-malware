from sklearn.externals import joblib
from sklearn.feature_extraction.text import TfidfVectorizer
from androguard.core.bytecodes.dvm import EncodedMethod
from androguard.misc import AnalyzeAPK


class Feature_Mapping_Generator:

    def __init__(self):
        self.source_code = []
        self.vectorizer = TfidfVectorizer()

    def retrieve_source_codes(self, apps):
        for app in apps:
            print('extracting code of ' + app.package)
            _, d, _ = AnalyzeAPK(app.path)
            for dalvik in d:
                for c_name in dalvik.get_classes_names():
                    if c_name.startswith('L'+app.get_package().replace('.', '/')):
                        # retrieve java code
                        # print(dalvik.get_class(c_name).get_source())
                        for method in dalvik.get_class(c_name).get_methods():
                            # method = m.get_method()
                            code = ""
                            byte_code = method.get_code()
                            if byte_code is not None:
                                byte_code = byte_code.get_bc()
                                for i in byte_code.get_instructions():
                                    code += i.get_name() + ' ' + i.get_output()
                            self.source_code.append(code)

    def build_feature_mapping(self):
        self.vectorizer.fit_transform(self.source_code)

    def export_mapping(self, path):
        joblib.dump(self.vectorizer, path)


class Feature_Generator:

    def __init__(self, mapping_path):
        self.vectorizer = joblib.load(mapping_path)

    def generate_features(self, callgraph):
        codes = []
        for method in callgraph.nodes:
            # only analyse "internal" methods (api calls are reresented in method code already
            if isinstance(method, EncodedMethod):
                print(method)
                # m.show()
                byte_code = method.get_code()
                if byte_code is not None:
                    byte_code = byte_code.get_bc()
                    if byte_code is not None:
                        code = ""
                        for i in byte_code.get_instructions():
                            code += i.get_name() + ' ' + i.get_output()
                        codes.append(code)
        print('Generate features for callgraph of size' + str(callgraph.order()))
        if len(codes) == 0:
            return 0
        return self.vectorizer.fit_transform(codes)