import glob
import random
import numpy as np

vt_reports_path = '/home/aesalem/Research/dejavu/data/vt_reports/'
package_hash_mapping = '/home/aesalem/Research/dejavu/data/lookup_structs/package_to_hash.txt'


def load_datasets(maldirs, gooddirs, percent_test, feature_regex='*.tfidf'):
    """
    generate labeled training and test data sets
    :param feature_regex: regex to filter feature types, default *.tfidf
    :param maldirs: list of malware paths
    :param gooddirs: list of goodware paths
    :param percent_test: percentage of test data
    :return:
    """
    # load good- and malware features from paths
    all_mal_features, y = load_features_from_path(maldirs, 1, feature_regex)
    all_good_features, y2 = load_features_from_path(gooddirs, 0, feature_regex)
    y += y2
    all_features = all_mal_features + all_good_features

    # randomize order (use zip to remember feature <-> label mapping)
    all_features, y = randomize_dataset(all_features, y)

    # divide data into train and test set
    training_data, test_data, y_train, y_test = split_dataset(list(all_features), list(y), percent_test)

    return training_data, test_data, y_train, y_test


def randomize_dataset(all_features, y):
    z = zip(all_features, y)
    random.shuffle(z)
    all_features, y = list(zip(*z))
    return list(all_features), list(y)


def load_hash_package_mapping():
    with open(package_hash_mapping, 'r') as inf:
        dict_from_file = eval(inf.read())
    return dict_from_file


def label_from_vt_report(filename):
    vt_report = eval(open(vt_reports_path + filename + '.report').read())
    print(vt_report['positives'])
    pos = vt_report['positives']
    if pos == 0:
        return 0
    elif pos >= 50:
        return 1
    else:
        return -1


def load_features_from_path(paths, label, criterion='*.tfidf'):
    """
    load tfidf features from path system
    :param criterion: feature data type
    :param paths: list of paths to load data from, important: path must end with /
    :param label: label to label data with
    :return:
    """
    package_to_hash = load_hash_package_mapping()
    if isinstance(paths, str):
        paths = [paths]
    feature_list, labels = [], []
    for path in paths:
        for f in list(glob.glob(path + criterion)):
            feature_list += [np.asarray(eval(open(f).read()))]
            package = f.rsplit('/', 1)[1].split('.tfidf')[0]
            # try to load label from vt, else use backup label
            try:
                labels.append(label_from_vt_report(package_to_hash[package]))
            except Exception as e:
                print(e)
                labels.append(label)
    return feature_list, [label] * len(feature_list)


def split_dataset(data, labels, percentage):
    num_split = int(round(percentage * len(data)))
    data_split, y_split = data[:num_split], labels[:num_split]
    data_rest, y_rest = data[num_split:], labels[num_split:]
    return data_rest, data_split, y_rest, y_split

def load_datasets_ordered():
    source_code_dir = '/home/miriam/malewaredetection/utils/source_codes/'
    training_data, y_train = load_features_from_path([source_code_dir + 's.home.aesalem.Research.Android.Datasets.Goodware.google_play./'], 0)
    t, y = load_features_from_path([source_code_dir + 's.home.aesalem.Research.Android.Datasets.Malware.AMD.amd_data./'], 1)
    training_data += t
    y_train += y

    test_data, y_test = load_features_from_path([source_code_dir + 's.home.aesalem.Research.Android.Datasets.Malware.MalGenome.genome./'], 1)
    t, y = load_features_from_path([source_code_dir + 's.home.aesalem.Research.Android.Datasets.Malware.AndroZoo_Piggybacking.piggybacked./'], 1)
    test_data += t
    y_test += y
    t, y = load_features_from_path([source_code_dir + 's.home.aesalem.Research.Android.Datasets.Malware.AndroZoo_Piggybacking.original./'], 0)
    test_data += t
    y_test += y

    training_data, y_train = randomize_dataset(training_data, y_train)

    return training_data, test_data, y_train, y_test
