# coding=utf-8
import numpy as np
import json
import os


def save_metrics_to_file(path, metricsDict):
    """
    Save metrics of training to json file
    :param path: path to store json
    :param metricsDict: metrics to save
    """
    with open(path, 'w+') as f:
        json.dump(metricsDict, f, sort_keys=True, indent=4)


def save_decision_tree(estimator, Xte, filename):
    """
    save decision tree to txt file with all data in nodes
    :param estimator: trained decision tree classifier
    :param Xte: Test data
    :param filename: path to store file
    """
    with open(filename, 'w+') as fh:
        n_nodes = estimator.tree_.node_count
        depth = estimator.tree_.max_depth
        children_left = estimator.tree_.children_left
        children_right = estimator.tree_.children_right
        feature = estimator.tree_.feature
        threshold = estimator.tree_.threshold
        value = estimator.tree_.value

        # The tree structure can be traversed to compute various properties such
        # as the depth of each node and whether or not it is a leaf.
        node_depth = np.zeros(shape=n_nodes, dtype=np.int64)
        is_leaves = np.zeros(shape=n_nodes, dtype=bool)
        stack = [(0, -1)]  # seed is the root node id and its parent depth
        while len(stack) > 0:
            node_id, parent_depth = stack.pop()
            node_depth[node_id] = parent_depth + 1

            # If we have a test node
            if children_left[node_id] != children_right[node_id]:
                stack.append((children_left[node_id], parent_depth + 1))
                stack.append((children_right[node_id], parent_depth + 1))
            else:
                is_leaves[node_id] = True

        fh.writelines("The binary tree structure has max_depth %s, %s nodes and has "
                      "the following tree structure:"
                      % (depth, n_nodes))
        for i in range(n_nodes):
            if is_leaves[i]:
                fh.writelines("\n%snode=%s leaf node -> %s." % (node_depth[i] * "\t", i, value[i][0]))
            else:
                fh.writelines("\n%snode=%s test node: go to node %s if X[:, %s] <= %s else to "
                              "node %s."
                              % (node_depth[i] * "\t",
                                 i,
                                 children_left[i],
                                 feature[i],
                                 threshold[i],
                                 children_right[i],
                                 ))
        fh.writelines('')

        # First let's retrieve the decision path of each sample. The decision_path
        # method allows to retrieve the node indicator functions. A non zero element of
        # indicator matrix at the position (i, j) indicates that the sample i goes
        # through the node j.

        node_indicator = estimator.decision_path(Xte)

        # Similarly, we can also have the leaves ids reached by each sample.

        leave_id = estimator.apply(Xte)

        # Now, it's possible to get the tests that were used to predict a sample or
        # a group of samples. First, let's make it for the sample.

        sample_id = 0
        node_index = node_indicator.indices[node_indicator.indptr[sample_id]:
                                            node_indicator.indptr[sample_id + 1]]

        fh.write('Rules used to predict sample %s: ' % sample_id)
        for node_id in node_index:
            if leave_id[sample_id] == node_id:
                continue
            if Xte[sample_id][feature[node_id]] <= threshold[node_id]:
                threshold_sign = "<="
            else:
                threshold_sign = ">"

            fh.writelines("\ndecision id node %s : (Xte[%s, %s] (= %s) %s %s)"
                          % (node_id,
                             sample_id,
                             feature[node_id],
                             Xte[sample_id][feature[node_id]],
                             threshold_sign,
                             threshold[node_id]))

        # For a group of samples, we have the following common node.
        sample_ids = [0, 1]
        common_nodes = (node_indicator.toarray()[sample_ids].sum(axis=0) ==
                        len(sample_ids))

        common_node_id = np.arange(n_nodes)[common_nodes]

        fh.writelines("\nThe following samples %s share the node %s in the tree"
                      % (sample_ids, common_node_id))
        fh.writelines("It is %s %% of all nodes." % (100 * len(common_node_id) / n_nodes,))


def non_default_arguments(arguments, argumentParser):
    """
    Find arguments that differ from default values to generate storename of experiment
    :param arguments: arguments of current expermint
    :param argumentParser: argument parser with default values
    :return: String representation of non-default arguments
    """
    argument_string = ''
    for arg in vars(arguments):
        if getattr(arguments, arg) != argumentParser.get_default(arg):
            argument_string += '-' + arg.capitalize() + str(getattr(arguments, arg)).capitalize()
    return argument_string


def save_decision_tree_png(clf, tfidf_features, storepath):
    """
    save decision tree as png file
    :param clf: trained decsion tree classifier
    :param tfidf_features: show if features are tfidf or engineered
    :param storepath: path to store tree
    """
    from sklearn.externals.six import StringIO
    from sklearn.tree import export_graphviz
    import pydotplus
    dot_data = StringIO()
    if not tfidf_features:
        feature_names = ['Min. SDK Version', 'Max. SDK Version', 'num of activities', 'num of services',
                         'num of broadcast receivers', 'num of content providers',
                         'Total requested permissions', 'Android permissions : total permissions',
                         'Custom permissions : total permissions', 'Dangerous permissions : total permissions',
                         'Total number of classes', 'Total number of methods', 'android.accounts.AccountManager',
                         'android.app.Activity', 'android.app.DownloadManager',
                         'android.app.IntentService', 'android.content.ContentResolver',
                         'android.content.ContextWrapper', 'android.content.pm.PackageInstaller',
                         'android.database.sqlite.SQLiteDatabase',
                         'android.hardware.Camera', 'android.hardware.display.DisplayManager',
                         'android.location.Location', 'android.media.AudioRecord', 'android.media.MediaRecorder',
                         'android.net.Network',
                         'android.net.NetworkInfo', 'android.net.wifi.WifiInfo', 'android.net.wifi.WifiManager',
                         'android.os.PowerManager', 'android.os.Process', 'android.telephony.SmsManager',
                         'android.widget.Toast',
                         'dalvik.system.DexClassLoader', 'dalvik.system.PathClassLoader', 'java.lang.class',
                         'java.lang.reflect.Method', 'java.net.HttpCookie', 'java.net.URL.openConnection',
                         'Category of Compiler according to APKiD']
    else:
        feature_names = [i.rsplit('\n', 1)[0].split(', ')[2] for i in
                         open('/home/miriam/malwaredetection/utils/source_codes/token_to_feature.txt')]
    export_graphviz(clf, out_file=dot_data, rounded=True, node_ids=True, feature_names=feature_names)
    graph = pydotplus.graph_from_dot_data(dot_data.getvalue())
    if os.path.isdir(storepath):
        os.remove(storepath)
    graph.write_png(storepath)


def prettyPrint(msg, mode="info"):
    """ copied from https://github.com/aleisalem/Aion/blob/master/utils/graphics.py
    Pretty prints a colored message. "info": Green, "error": Red, "warning": Yellow, "info2": Blue, "output": Magenta,
     "debug": White
    """
    if mode == "info":
        color = "32"  # Green
    elif mode == "error":
        color = "31"  # Red
    elif mode == "warning":
        color = "33"  # Yellow
    elif mode == "info2":
        color = "34"  # Blue
    elif mode == "output":
        color = "35"  # Magenta
    elif mode == "debug":
        color = "37"  # White
    else:
        color = "32"
    msg = "[*] %s. %s" % (msg, getTimestamp(includeDate=True))
    # print("\033[1;%sm%s\n%s\033[1;m" % (color, msg, '-'*len(msg))) # Print dashes under the message
    print("\033[1;%sm%s\033[1;m" % (color, msg))


def prettyPrintError(ex):
    """ Pretty prints an error/exception message """
    import sys
    exc_type, exc_obj, exc_tb = sys.exc_info()
    fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
    msg = "Error \"%s\" encountered in \"%s\" line %s: %s" % (exc_type, fname, exc_tb.tb_lineno, ex)
    prettyPrint(msg, "error")


def getTimestamp(includeDate=False):
    """
    get timestamp for pretty print
    :param includeDate: include date in print
    :return:
    """
    from datetime import datetime
    if includeDate:
        return "[%s]" % str(datetime.now())
    else:
        return "[%s]" % str(datetime.now()).split(" ")[1]
