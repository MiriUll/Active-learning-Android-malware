from gensim.corpora import dictionary
from utils.config import *
from utils.utils import *
from shutil import copyfile
import os
import json
import glob


def gen_package_to_family_mapping():
    path = '/home/aesalem/Research/Android/Datasets/Malware/AMD/amd_data/'
    hash_to_family_mapping = {}
    for fam in os.listdir(path):
        if os.path.isdir(path + fam):
            print(path + fam)
            for app in glob.glob(path + fam + '/**/*.apk'):
                hash_to_family_mapping[(app.rsplit('/', 1)[1]).rsplit('.', 1)[0]] = fam
    with open('hash_to_family_mapping.txt', 'w+') as fh:
        fh.write(json.dumps(hash_to_family_mapping))


def copy_subset_to_new_path():
    with open('/home/miriam/malwaredetection/utils/source_codes/training_amd/fixed_amd_subset.txt', 'r') as f:
        for line in f:
            copyfile('/home/miriam/malwaredetection/utils/source_codes/training_amd/s.home.aesalem.Research.Android.Datasets.Malware.AMD.amd_data./' + line.strip('\n') + '.txt', '/home/miriam/malwaredetection/utils/source_codes/training_amd/amd_subset/' + line.strip('\n') + '.txt')
            copyfile('/home/miriam/malwaredetection/utils/source_codes/training_amd/s.home.aesalem.Research.Android.Datasets.Malware.AMD.amd_data./' + line.strip('\n') + '.tfidf', '/home/miriam/malwaredetection/utils/source_codes/training_amd/amd_subset/' + line.strip('\n') + '.tfidf')


def select_subset_and_save():
    with open('/home/miriam/malwaredetection/package_to_family.txt', 'r') as inf:
        package_to_family = eval(inf.read())
    source_code_dir = '/home/miriam/malwaredetection/utils/source_codes/training_amd/s.home.aesalem.Research.Android.Datasets.Malware.AMD.amd_data./'
    amd_data = {}
    for f in list(glob.glob(source_code_dir + '*.tfidf')):
        package = f.rsplit('/', 1)[1].split('.tfidf')[0]

        try:
            fam = package_to_family[package]
            if fam in amd_data:
                amd_data[fam].append(package)
            else:
                amd_data[fam] = [package]
        except KeyError:
            print('hash not in mapping')

    amd_subset = []
    '''while len(amd_subset) < 3000:
        for f in amd_data.keys():
            print(f, len(amd_data[f]))
            if len(amd_data) > 0:
                amd_subset += amd_data[f].pop(random.randint(0, len(amd_data[f])))'''
    for f in amd_data.keys():
        num_elements = int(0.2 * len(amd_data[f]))
        random.shuffle(amd_data[f])
        amd_subset += amd_data[f][:num_elements]
    print(len(amd_subset))
    with open('/home/miriam/malwaredetection/utils/source_codes/training_amd/fixed_subset.txt', 'w+') as f:
        for d in amd_subset:
            f.write(d + '\n')


if __name__ == '__main__':
    id2token_dictionary = dictionary.Dictionary.load_from_text(corpus_path)
    tokenTuples = [tuple(map(int, i.split(' '))) for i in open(feature_mapping_path)]
    with open('/home/miriam/malwaredetection/utils/source_codes/token_to_feature.txt', 'w+') as fh:
        for i in range(500):
            tokenKey = tokenTuples[i][0]
            fh.write(str(i) + str(tokenKey) + str(id2token_dictionary[tokenKey]) + '\n')
    #from utils. generate_feature_mapping import generate_feature_mapping
    #generate_feature_mapping()
    #with open('/home/anschutzm/PycharmProjects/malewaredetection/utils/fixed_amd_subset.txt', 'r') as f:
     #   print(len(f.read().splitlines()))
    #wih open('/home/anschutzm/PycharmProjects/malewaredetection/utils/fixed_amd_subset_hashes.txt', 'r') as out:
       # print(len(out.read().splitlines()))
    """fg = Feature_Mapping_Generator()
    fg.retrieve_source_codes(maleware_path)
    fg.retrieve_source_codes(goodware_path)
    print(len(fg.source_code))
    fg.build_feature_mapping()
    fg.export_mapping()
    wg = Window_Generator()
    for i in range(0, 50):
        res = wg.next_training_data(True)
        while res is not None:
            res = wg.next_training_data(False)"""
    #training_data, test_data = preprocess.preprocess(True)
    #a = AnalysedAPK(goodware_path + '00a7478f356bfe2d1ed19785f002c1b15f2a3827404e3009c320fdfbf505be2a.apk', 0)
    #a.export_graph(goodware_path + 'export')
    #from networkx import read_edgelist
    #g = read_edgelist(goodware_path + 'export')
    #print g
    #source_code_dir = '/home/miriam/malewaredetection/utils/source_codes/'
    #training_data, y_train = load_features_from_path([source_code_dir + 's.home.aesalem.Research.Android.Datasets.Goodware.google_play./'], 0)
    '''_, _, y_train_orig, y_test_orig, _, _ = load_datasets_ordered(balance_factor=1.0, labeling_schema='original', compare_vt=False, ignore_ambiguous=False)
    _, _, y_train_zero, y_test_zero, _, _ = load_datasets_ordered(balance_factor=1.0, labeling_schema='zero', compare_vt=True, ignore_ambiguous=False)
    _, _, y_train_fifty, y_test_fifty, _, _ = load_datasets_ordered(balance_factor=1.0, labeling_schema='fifty_percent', compare_vt=True, ignore_ambiguous=False)


    for i, l in enumerate(y_test_orig):
        if l == y_test_fifty[i] and l == y_test_zero[i]:
            print(i)'''
