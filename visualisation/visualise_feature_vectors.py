# coding=utf-8
# !/usr/bin/python
import numpy
from utils.data_organisation import load_features_from_path, load_fixed_subset
from visualisation.visualise_data import *
import glob
import argparse

feature_paths = {}
tfidf_parent_dir = '/home/miriam/malwaredetection/utils/source_codes/training_subset/'
engineered_parent_dir = '/home/aesalem/Research/dejavu/data/feature_vectors/'
feature_paths['tfidf'], feature_paths['engineered'] = {}, {}
feature_paths['tfidf']['training'] = [tfidf_parent_dir + 'amd/',
                                      tfidf_parent_dir + 's.home.aesalem.Research.Android.Datasets.Goodware.google_play./']
feature_paths['tfidf']['test'] = [
    tfidf_parent_dir + 's.home.aesalem.Research.Android.Datasets.Malware.AndroZoo_Piggybacking.piggybacked./',
    tfidf_parent_dir + 's.home.aesalem.Research.Android.Datasets.Malware.AndroZoo_Piggybacking.original./']
feature_paths['engineered']['training'] = ['amd', engineered_parent_dir + 'gplay/static/']
feature_paths['engineered']['test'] = [engineered_parent_dir + 'piggybacked_only/static/',
                                       engineered_parent_dir + 'original_only/static/']


def defineArguments():
    parser = argparse.ArgumentParser(prog="visualise_feature_vectors.py",
                                     description="A tool to reduce the dimensionality of data points and visualize"
                                                 " them in 2- or 3-D.")
    parser.add_argument("-t", "--train_test", help="Plot training or test data", choices=["training", "test"],
                        required=True)
    parser.add_argument("-f", "--features", help="Decide which features to print", choices=["tfidf", "engineered"],
                        required=True)
    parser.add_argument("-ti", "--title", required=False, default='')
    parser.set_defaults(compare_virus_total=True)
    parser.add_argument("-s", "--labeling_scheme", help="labeling scheme for vt labels", required=False, default="zero",
                        choices=["zero", "fifty_percent", "original"])
    parser.add_argument("-a", "--algorithm", help="The dimensionality reduction algorithm to use", required=False,
                        default="pca", choices=["tsne", "pca"])
    parser.add_argument("-d", "--dimensionality",
                        help="The target dimensionality to which the feature vectors are projected", required=False,
                        default="2", choices=["2", "3"])
    parser.add_argument("-si", "--figuresize", help="The size of the Plotly figure", required=False,
                        default="(1024, 1024)")
    return parser


def main():
    argumentParser = defineArguments()
    arguments = argumentParser.parse_args()
    # is labeling scheme is original, we will not compare the virusTotal reports
    if arguments.labeling_scheme == "original":
        arguments.compare_virus_total = False

    f_ext = '.tfidf' if arguments.features == 'tfidf' else '.static'
    print_vectors(feature_paths[arguments.features][arguments.train_test], [1, 0], arguments, f_ext)


def print_vectors(paths, labels, arguments, fileExtension):
    """
    print feature vectors as defined in arguments
    :param paths: paths of respective data
    :param labels: labels of data
    :param arguments: arguments of plot
    :param fileExtension: fileextension to load vectors from path
    :return:
    """
    # Retrieve the data
    appNames = []
    X, y = [], []
    for i, path in enumerate(paths):
        # allFiles += glob.glob("%s/*.%s" % (path, fileExtension))
        if path == 'amd':
            appNames = [f.strip('\n') for f in open(
                '/home/miriam/malwaredetection/utils/source_codes/training_amd/fixed_amd_subset_hashes.txt', 'r')]
            x_p, y_p = load_fixed_subset(1, arguments.labeling_scheme, arguments.compare_virus_total, fileExtension)
        else:
            appNames += ([f.rsplit('/', 1)[1].strip(fileExtension) for f in glob.glob(path + '*' + fileExtension)])
            x_p, y_p = load_features_from_path(path, int(labels[i]), arguments.labeling_scheme,
                                               arguments.compare_virus_total, criterion=fileExtension)
            print(len(x_p))
        X += x_p
        y += y_p
    if len(X) < 1:
        prettyPrint("Could not retrieve any \"%s\" files from the dataset directory \"%s\". Exiting" % (
            fileExtension, paths), "warning")
        return False
    prettyPrint("Successfully retrieved %s \"%s\" files from the dataset directory \"%s\"" % (
        len(X), fileExtension, paths))
    X = numpy.array(X)
    y = numpy.array(y)
    # Perform visualization
    figureTitle = arguments.features + ' ' + arguments.train_test + ' features, labeling scheme ' + \
                  arguments.labeling_scheme if arguments.title == '' else arguments.title
    reduceAndVisualize(X, y, int(arguments.dimensionality), arguments.algorithm, eval(arguments.figuresize),
                       figureTitle, appNames)

    return True


if __name__ == "__main__":
    main()
